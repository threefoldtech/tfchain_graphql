type Entity @entity {
  gridVersion: Int!
  entityID: Int!
  name: String!
  country: String
  city: String
  accountID: String!
}

type Twin @entity {
  gridVersion: Int!
  twinID: Int! @index
  accountID: String!
  relay: String
  publicKey: String
}

type EntityProof @entity {
  entityID: Int!
  signature: String!
  twinRel: Twin!
}

type Farm @entity {
  gridVersion: Int!
  farmID: Int! @index
  name: String!
  twinID: Int!
  pricingPolicyID: Int!
  certification: FarmCertification
  publicIPs: [PublicIp!] @derivedFrom(field: "farm")
  totalIps: Int!
  freeIps: Int!
  stellarAddress: String
  dedicatedFarm: Boolean
}

type PublicIp @entity {
  farm: Farm!
  gateway: String!
  ip: String!
  contractId: BigInt @index
}

type Node @entity {
  gridVersion: Int!
  nodeID: Int! @index
  farmID: Int!
  twinID: Int!
  location: Location!
  country: String
  city: String
  publicConfig: PublicConfig @derivedFrom(field: "node")
  uptime: BigInt
  created: Int!
  farmingPolicyId: Int!
  interfaces: [Interfaces!] @derivedFrom(field: "node")
  certification: NodeCertification
  secure: Boolean
  virtualized: Boolean
  serialNumber: String
  createdAt: BigInt!
  updatedAt: BigInt!
  connectionPrice: Int
  power: NodePower
  dedicated: Boolean!
  extraFee: BigInt
  totalCRU: BigInt!
  totalHRU: BigInt!
  totalSRU: BigInt!
  totalMRU: BigInt!
  freeMRU: BigInt! @index
  freeHRU: BigInt! @index
  freeSRU: BigInt! @index
  rentedBy: Int
}

type NodePower {
  state: PowerState!
  target: Power!
}

enum PowerState {
  Up
  Down
}

enum Power {
  Up
  Down
}

type Interfaces @entity {
  node: Node!
  name: String!
  mac: String!
  ips: String!
}

enum FarmCertification {
  NotCertified
  Gold
}

enum NodeCertification {
  Diy
  Certified
}

type PublicConfig @entity {
  node: Node! @unique
  ipv4: String
  ipv6: String
  gw4: String
  gw6: String
  domain: String
}

type Location @entity {
  longitude: String!
  latitude: String!
}

type PricingPolicy @entity {
  gridVersion: Int!
  pricingPolicyID: Int!
  name: String!
  su: Policy!
  cu: Policy!
  nu: Policy!
  ipu: Policy!
  foundationAccount: String!
  certifiedSalesAccount: String!
  dedicatedNodeDiscount: Int!
}

type Policy {
  value: Int
  unit: String
}

type Country @entity {
  countryID: Int!
  code: String!
  name: String!
  region: String!
  subregion: String!
  lat: String
  long: String
}

type City @entity {
  cityID: Int!
  countryID: Int!
  name: String!
}

type Contract @entity{
  gridVersion: Int!
  contractID: BigInt! @index
  twinID: Int!
  nodeID: Int
  deploymentData: String
  deploymentHash: String
  numberOfPublicIPs: Int
  state: ContractState! @index
  createdAt: BigInt!
  solutionProviderID: Int
  usedCRU: BigInt
  usedMRU: BigInt
  usedSRU: BigInt
  usedHRU: BigInt
  name: String
  type: ContractType! @index
}

type SolutionProvider @entity {
  solutionProviderID: BigInt!
  description: String!
  link: String!
  approved: Boolean!
  providers: [Provider]
}

type Provider {
  who: String!
  take: Int!
}

enum ContractState {
  Created
  Deleted
  OutOfFunds
  GracePeriod
}

enum ContractType {
  Node
  Name
  Rent
}

type NruConsumption @entity {
  contractID: BigInt!
  timestamp: BigInt!
  window: BigInt
  nru: BigInt
}

type ContractBillReport @entity {
  contractID: BigInt! @index
  discountReceived: DiscountLevel!
  amountBilled: BigInt!
  timestamp: BigInt!
}

enum DiscountLevel {
  None
  Default
  Bronze
  Silver
  Gold
}

type FarmingPolicy @entity {
  gridVersion: Int!
  farmingPolicyID: Int!
  name: String
  cu: Int
  su: Int
  nu: Int
  ipv4: Int
  minimalUptime: Int
  policyCreated: Int
  policyEnd: Int
  immutable: Boolean
  default: Boolean
  nodeCertification: NodeCertification
  farmCertification: FarmCertification
}

type UptimeEvent @entity {
  nodeID: Int!
  uptime: BigInt!
  timestamp: BigInt!
}

type MintTransaction @entity {
  amount: BigInt!
  target: String!
  block: Int!
}

type BurnTransaction @entity {
  block: Int!
  amount: BigInt!
  target: String!
}

type RefundTransaction @entity {
  block: Int!
  amount: BigInt!
  target: String!
  txHash: String!
}

type ServiceContract @entity {
  serviceContractID: BigInt!
  serviceTwinID: Int!
  consumerTwinID: Int!
  baseFee: BigInt!
  variableFee: BigInt!
  metadata: String!
  acceptedByService: Boolean!
  acceptedByConsumer: Boolean!
  lastBill: BigInt!
  state: ServiceContractState!
}

enum ServiceContractState {
  Created
  AgreementReady
  ApprovedByBoth
}

type ServiceContractBill @entity {
  serviceContractID: BigInt!
  variableAmount: BigInt!
  window: BigInt!
  metadata: String
  amount: BigInt!
}
